\chapter{Proof of Concept}

Für die Einarbeitung in die Gephi-Plugin Entwicklung und erste Ansätze für die Umsetzung des Projekts zu finden, hat
sich das Projektteam entschlossen, ein Proof of Concept umzusetzen.

\section{Ziel}

Das Ziel des Proof of Concept ist es, sich mit dem API von Gephi vertraut zu machen sowie simple Konzepte, welche im
Projekt benötigt werden, umzusetzen.

\section{Umsetzungsprozess}

\subsection{Filter}

Filter werden in Gephi verwendet, um ein Netzwerk auf Knoten oder Kanten zu reduzieren, welche bestimmte Eigenschaften besitzen.
In Bezug auf Link-Prediction wurde deshalb eine neue Filterkategorie eingeführt, unter welcher nach verschiedenen Prediction-Algorithmen gefiltert werden kann.
Durch Auswahl eines Algorithmus können jene Kanten herausgefiltert werden, welche durch Anwenden des Algorithmus neu hinzugefügt werden.
Der Filter wird dabei um ein UI-Element ergänzt, bei welchem die Anzahl der hinzufügten Kanten eingegrenzt werden kann.

\subsection{Statistiken}

Da für die Link Prediction eine neue Statistik eingeführt werden muss, die mit den verschiedenen Algorithmen Werte und
neue Kanten errechnet, schien es sinnvoll, ausserdem eine Logik für Statistiken einzubauen.

In einem ersten Schritt wurde hier eine Funktion eingebaut, welche die Anzahl Nachbarn jedes Knotens zählt. Dazu wurde
zuerst unter Statistiken ein neuer Button "Count Neighbours" hinzugefügt, anschliessend die Logik, die auf einem der
Beispiele aus dem Gephi-Plugin Bootcamp beruht.

Diese Logik war sehr einfach, da es Funktionen dafür gibt, jeden Knoten aus dem Graphen auszulesen und dann pro Knoten
die Nachbarn auszulesen. Diese können dann gezählt und die Werte dann im Data Laboratory abgelegt werden.

Da für die Umsetzung der Link Prediction aber nicht nur die direkte Anzahl der Nachbarn relevant ist, sondern vor allem
die Zahl der gemeinsamen Nachbarn zweier Knoten wurde auch dafür noch eine Statistik umgesetzt. Hier werden nacheinander
die Knoten durchgegangen und getestet, wie viele ihrer Nachbarn mit den Nachbarn eines anderen Knotens übereinstimmen.
Wenn es noch keine Kante zwischen den beiden Knoten gibt, wird eine neue hinzugefügt und die Anzahl der gemeinsamen
Knoten als neues Attribut eingefügt. Wenn es die Kante bereits gibt, wird nur das neue Attribut befüllt. Zusätzlich
gibt es ein Attriut, das anzeigt, ob die Kante hinzugefügt wurde oder ob sie schon existiert hat. Zur Berechnung der
gemeinsamen Nachbarn werden darüber hinaus nur Kanten gewertet, die nicht erst bei der Berechnung hinzugefügt worden
sind.

Damit dem Graphen Kanten hinzugefügt werden können, während diese noch gelesen und überarbeitet werden, musste statt
dem Read-Lock der "Anzahl Nachbarn"-Statistik, ein Write-Lock verwendet werden. Diese Erkenntnis wird auch bei der
späteren Implementierung relevant sein. Ausserdem hat es auch eine Weile gedauert, die Logik für das Zählen der
gemeinsamen Nachbarn zu erarbeiten. Dies wird aber sehr hilfreich sein, wenn es an die eigentliche Implementierung geht.

\section{Erkenntnisse}

Es konnten viele Erkenntnisse aus der Umsetzung des Proof Of Concept gezogen werden.

Zum einen war es sehr hilfreich, sich zum ersten Mal aktiv mit dem API von Gephi zu beschäftigen. Besonders hilfreich
war dies auch, weil die Beispiele aus dem Bootcamp bereits veraltet sind und so, wie sie zur Verfügung stehen, nicht
mehr einfach genutzt werden können.

Des Weiteren konnte mit Hilfe des Proof Of Concept sichergestellt werden, dass die Installationen auf den Rechnern des
Projektteams funktioniert und angewendet werden kann sowie dass sich beide Personen in der Umgebung zurechtfinden und
diese für die Umsetzung nutzen konnen. Viele Probleme konnten hier bereits erkannt und behoben werden.

Vom technischen Aspekt her konnten so auch wichtige Fragen für die spätere Umsetzung geklärt werden, beispielsweise
wie ein Gephi-Plugin aufgebaut ist. Dies hilft dem Team, um erste Ansätze für die Software Architektur zu entwerfen.
Das Konzept dafür befindet sich im entsprechenden Kapitel. Um ein Beispiel zu nennen, konnte nach der Umsetzung des
Proof of Concept aber bereits festgelegt werden, wie sichergestellt werden kann, dass die Anzahl Algorithmen für die
Link Prediction beliebig erweitert werden kann, nämlich indem diverse Informationen in separate Klassen ausgelagert
werden und es für jeden Algorithmus eine eigene Subklasse gibt, die grundsätzlich nur noch die Umsetzung des Algorithmus
implementiert, jedoch nichts mit dessen Aufruf zu tun hat.
